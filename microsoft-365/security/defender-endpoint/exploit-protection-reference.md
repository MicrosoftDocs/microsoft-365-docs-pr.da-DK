---
title: Exploit protection-reference
keywords: afhjælpninger, sårbarheder, risiko, afhjælpning, udnyttelse, udnyttelse, emet
description: Oplysninger om, hvordan funktionen til udnyttelse af beskyttelse fungerer i Windows
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
ms.localizationpriority: medium
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.collection: m365-security-compliance
ms.date: 10/19/2021
ms.openlocfilehash: f6889cb12f1a152abe3dbb7d748d52e118547ab3
ms.sourcegitcommit: bdd6ffc6ebe4e6cb212ab22793d9513dae6d798c
ms.translationtype: MT
ms.contentlocale: da-DK
ms.lasthandoff: 03/08/2022
ms.locfileid: "63597562"
---
# <a name="exploit-protection-reference"></a>Exploit Protection Reference

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**Gælder for:**
- [Microsoft Defender for Endpoint Plan 2](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

> Vil du opleve Microsoft Defender til slutpunkt? [Tilmeld dig for at få en gratis prøveversion.](https://signup.microsoft.com/create-account/signup?products=7f379fee-c4f9-4278-b0a1-e4c8c2fcdf7e&ru=https://aka.ms/MDEp2OpenTrial?ocid=docs-wdatp-enablesiem-abovefoldlink)

Exploit Protection giver avanceret beskyttelse til programmer, som it-Pro kan anvende, når udvikleren har kompileret og distribueret softwaren.

Denne artikel hjælper dig med at forstå, hvordan udnyttelse af beskyttelse fungerer, både på politikniveau og på det individuelle afhjælpningsniveau, så du kan opbygge og anvende exploit Protection-politikker.

## <a name="how-mitigations-are-applied"></a>Sådan anvendes afhjælpninger

Afhjælpning af udnyttelse anvendes i de forskellige programmer.

Afhjælpninger konfigureres via en post i registreringsdatabasen for hvert program, du konfigurerer beskyttelse mod. Disse indstillinger er gemt i posten **MitigationOptions i registreringsdatabasen** for hvert program (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions**). De træder i kraft, når du genstarter programmet og forbliver effektive, indtil du ændrer dem og genstarter programmet igen.

> [!IMPORTANT]
> Indstillinger for udførelse af billedfil gør det kun muligt at angive et filnavn eller en sti, ikke et versionsnummer, en arkitektur eller en anden differentiator. Sørg for at målrette afhjælpninger mod apps, der har entydige navne eller stier, ved kun at anvende dem på enheder, hvor du har testet den pågældende version og den pågældende arkitektur for programmet.

Hvis du konfigurerer afhjælpning af udnyttelse af beskyttelse ved hjælp af en XML-konfigurationsfil, enten via PowerShell, Gruppepolitik eller MDM, når du behandler denne XML-konfigurationsfil, konfigureres individuelle indstillinger i registreringsdatabasen for dig.

Når politikken til distribution af XML-filen ikke længere håndhæves, fjernes de indstillinger, der er installeret af denne XML-konfigurationsfil, ikke automatisk. Hvis du vil fjerne indstillingerne for Exploit Protection, skal du eksportere XML-konfigurationen fra en Windows 10 eller Windows 11-enhed og installere denne nye XML-fil. Alternativt leverer Microsoft en XML-fil som en del Windows Sikkerhed oprindelige planer til nulstilling af indstillinger for Exploit Protection.

Hvis du vil nulstille indstillinger for udnyttelse af beskyttelse ved hjælp af PowerShell, kan du bruge følgende kommando:

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
Følgende er den EP-reset.xml, der fordeles med Windows Sikkerhed Oprindelige planer:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>Reference til afhjælpning

De følgende afsnit beskriver de beskyttelser, der leveres af hver enkelt afhjælpning af udnyttelse, overvejelser om kompatibilitet for afhjælpningen og de tilgængelige konfigurationsmuligheder.

## <a name="arbitrary-code-guard"></a>Tilfældig code guard

### <a name="description"></a>Beskrivelse

Vilkårlig code guard hjælper med at beskytte mod en ondsindet hacker, der indlæser koden efter eget valg i hukommelsen gennem en hukommelsessikkerhedsrisiko og kan udføre denne kode.

Vilkårlig kode beskytter et program mod at udføre dynamisk genereret kode (kode, der ikke indlæses, f.eks. fra selve exe eller en dll-fil). Tilfældig code guard fungerer ved at forhindre hukommelse i at blive markeret som eksekverbar. Når et program forsøger [at tildele hukommelse](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), kontrollerer vi beskyttelseflagene. (Hukommelse kan tildeles med flag til læse-, skrive- og/eller eksekveringsbeskyttelse. Hvis allokeringsforsøgene [*på at*](/windows/win32/memory/memory-protection-constants) medtage flaget til udførelse af beskyttelse mislykkes, og der returneres en fejlkode (STATUS_DYNAMIC_CODE_BLOCKED). På samme måde gælder det, at hvis et program forsøger at ændre beskyttelseflag for hukommelse, som allerede er blevet [](/windows/win32/memory/memory-protection-constants) tildelt og omfatter flaget til [udførselsbeskyttelse, så mislykkes tilladelsesændringen](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect), og der returneres en fejlkode (STATUS_DYNAMIC_CODE_BLOCKED).

Ved at forhindre, at der indstilles et flag til udførsel, kan funktionen til forebyggelse af datakørsel i Windows 10 og Windows 11 derefter beskyttes mod, at instruktionsmarkøren indstilles til den pågældende hukommelse og kører denne kode.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Vilkårlig code guard forhindrer, at al hukommelse tildeles som eksekverbar, hvilket præsenterer et kompatibilitetsproblem med metoder som Just-in-Time-compilere (JIT). De fleste moderne browsere kompileres f.eks. JavaScript i indbygget kode for at optimere ydeevnen. For at understøtte denne afhjælpning skal de omarbejdes for at flytte JIT-kompileringen uden for den beskyttede proces. Andre programmer, hvis design dynamisk genererer kode fra scripts eller andre mellemliggende sprog, vil være tilsvarende inkompatible med denne afhjælpning.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Tillad fravalg af tråd** – Du kan konfigurere afhjælpningen, så en enkelt tråd fravælger denne beskyttelse. Udvikleren skal have skrevet programmet med kendskab til denne afhjælpning og have kaldt [**SetThreadInformation**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) API'en med parameteren *ThreadInformation* angivet til **ThreadDynamicCodePolicy** for at få lov til at udføre dynamisk kode på denne tråd.

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-low-integrity-images"></a>Bloker billeder med lav integritet

### <a name="description"></a>Beskrivelse

Bloker billeder med lav integritet forhindrer programmet i at indlæse filer, der ikke er tillid til, typisk fordi de er blevet downloadet fra internettet fra en sandkassebrowser.

Denne afhjælpning blokerer billedindtastning, hvis billedet har en Access Control Entry (ACE), som giver adgang til Low IL-processer, og som ikke har en trust label ACE. Det implementeres af hukommelsesstyringen, hvilket forhindrer filen i at blive tilknyttet i hukommelsen. Hvis et program forsøger at kortlægge et billede med lav integritet, vil det udløse en STATUS_ACCESS_DENIED fejl. Hvis du vil have mere at vide om, hvordan integritetsniveauer fungerer, [skal du se Obligatorisk kontrol af integritet](/windows/win32/secauthz/mandatory-integrity-control).

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Bloker billeder med lav integritet forhindrer programmet i at indlæse filer, der er blevet downloadet fra internettet. Hvis arbejdsprocessen for programmer kræver indlæsning af billeder, der downloades, skal du sikre dig, at de downloades fra en proces, der har større tillid til, eller udtrykkeligt angives igen for at afhjælpe problemet.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Microsoft Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-remote-images"></a>Bloker eksterne billeder

### <a name="description"></a>Beskrivelse

Blokering af eksterne billeder hjælper med at forhindre programmet i at indlæse filer, der er hostet på en ekstern enhed, f.eks. en UNC-deling. Blokering af eksterne billeder er med til at beskytte dig mod at indlæse binære i hukommelsen, der er på en ekstern enhed, der styres af hackeren.

Denne afhjælpning blokerer billedbelastninger, hvis det vurderes, at billedet ligger på en ekstern enhed. Det implementeres af hukommelsesstyringen, hvilket forhindrer filen i at blive tilknyttet i hukommelsen. Hvis et program forsøger at tilknytte en ekstern fil, udløser det en STATUS_ACCESS_DENIED fejl.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Bloker eksterne billeder forhindrer programmet i at indlæse billeder fra eksterne enheder. Hvis dit program indlæser filer eller plug-ins fra eksterne enheder, vil det ikke være kompatibelt med denne afhjælpning.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Microsoft Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-untrusted-fonts"></a>Bloker upålidelige skrifttyper

### <a name="description"></a>Beskrivelse

Bloker upålidelige skrifttyper mindsker risikoen for en sårbarhed i skrifttype parsing, der fører til, at hackeren kan køre kode på enheden. Kun skrifttyper, der er installeret i mappen windows\fonts, indlæses til behandling af GDI.

Denne afhjælpning er implementeret i GDI, som validerer filens placering. Hvis filen ikke er i mappen med systemskrifttyper, indlæses skrifttypen ikke til fortolkning, og det pågældende opkald mislykkes.

Denne afhjælpning er i tillæg til den indbyggede afhjælpning, der findes i Windows 10 1607 og nyere, og Windows 11, som flytter skrifttypen fortolkninger ud af kerne og i en brugertilstandsappbeholder. Enhver udnyttelse baseret på skrifttypeparering sker derfor i en sandkasse og isoleret kontekst, hvilket reducerer risikoen betydeligt. Du kan finde flere oplysninger om denne afhjælpning på bloggen [Hardening Windows 10 afhjælpninger uden for dagen](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/).

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Den mest almindelige brug af skrifttyper uden for systemets skrifttypekatalog er med [webskrifttyper](/typography/fonts/font-faq#web). Moderne browsere, f.eks. Microsoft Edge, bruger DirectWrite I stedet for GDI, og påvirkes ikke. Ældre browsere, f.eks. Internet Explorer 11 (og IE-tilstand i den nye Microsoft Edge), kan dog blive påvirket, især i forbindelse med programmer som f.eks. Office 365, der bruger skrifttypeglyphs til at vise UI.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Microsoft Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="code-integrity-guard"></a>Code integrity guard

### <a name="description"></a>Beskrivelse

Code integrity guard sikrer, at alle binære, der indlæses i en proces, er digitalt signeret af Microsoft. Code integrity guard omfatter [WHQL-signaturer](/windows-hardware/drivers/install/whql-release-signature) (Windows Hardware Quality Labs), som gør det muligt for WHQL-godkendte drivere at køre i processen.

Denne afhjælpning er implementeret i hukommelsesstyringen, hvilket blokerer den binære fra at blive knyttet til hukommelsen. Hvis du forsøger at indlæse en binær fil, der ikke er signeret af Microsoft, vil hukommelses manger returnere STATUS_INVALID_IMAGE_HASH. Ved at blokere på hukommelsesstyringsniveauet forhindrer dette både binære indlæst af processen og binære, der er indsat i processen.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Denne afhjælpning blokerer specifikt binære filer, der ikke er signeret af Microsoft. Det er derfor ikke kompatibelt med de fleste tredjepartsprogrammer, medmindre softwaren distribueres af (og digitalt signeret af) Microsoft Store, og muligheden for at tillade indlæsning af billeder signeret af Microsoft Store vælges.

### <a name="configuration-options"></a>Konfigurationsindstillinger

Tillad også indlæsning af billeder, der er signeret af **Microsoft Store** – Programmer, der er distribueret af Microsoft Store, signeres digitalt af Microsoft Store, og hvis du tilføjer denne konfiguration, kan binære, der har gennemgået certificeringsprocessen for Store, indlæses af programmet.

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Microsoft Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="control-flow-guard-cfg"></a>Control flow guard (CFG)

### <a name="description"></a>Beskrivelse

Control Flow Guard (CFG) reducerer risikoen for hackere, der bruger sårbarheder i forbindelse med hukommelsestab ved at beskytte indirekte funktionsopkald. En hacker kan f.eks. bruge en bufferoverløbssikkerhedsrisiko til at overskrive hukommelse, der indeholder en funktionsmarkør, og erstatte funktionsmarkøren med en markør til en eksekverbar kode efter eget valg (som også kan være blevet tilføjet i programmet).

Denne afhjælpning kan afhjælpes ved at indsætte endnu en kontrol på kompileringstiden. Før hvert indirekte funktionsopkald tilføjes der en anden vejledning, som bekræfter, at destinationen er en gyldig opkalds destination, før den kaldes. Hvis destinationen ikke er en gyldig opkalds destination, afsluttes programmet. Derfor kan kun programmer, der kompileres med CFG-support, drage fordel af denne afhjælpning.

Kontrol af en gyldig destination leveres af Windows kerne. Når eksekverbare filer indlæses, udtrækkes metadataene for indirekte opkalds mål ved indlæsningstid og markeres som gyldige opkaldsmål. Når hukommelsen er allokeret og markeret som eksekverbar (f.eks. for genereret kode), markeres disse hukommelsesplaceringer også som gyldige opkaldsmål for at understøtte mekanismer som JIT-kompilering.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Da programmer skal kompileres for at understøtte CFG, erklærer de implicit deres kompatibilitet med den. De fleste programmer bør derfor arbejde med denne afhjælpning aktiveret. Da disse kontroller kompileres til den binære, er den konfiguration, du kan anvende, blot at deaktivere kontroller i Windows kerne. Med andre ord er afhjælpningen som standard angivet, men du kan konfigurere Windows-kernen til altid at returnere "ja", hvis du senere finder ud af, at der er et kompatibilitetsproblem, som programudvikleren ikke har opdaget i sin test, hvilket bør være sjældent.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Brug streng CFG** – I streng tilstand skal alle binære, der indlæses i processen, kompileres for Control Flow Guard (eller ikke har nogen eksekverbar kode i dem – f.eks. ressource dlls) for at kunne indlæses.

> [!Note]
> **Control Flow Guard** har ingen overvågningstilstand. Binære kompileres med denne afhjælpning aktiveret.

## <a name="data-execution-prevention-dep"></a>Forhindring af datakørsel

### <a name="description"></a>Beskrivelse

Forhindring af datakørsel forhindrer hukommelse, der ikke eksplicit blev tildelt som eksekverbar, i at blive udført. DEP hjælper med at beskytte mod en hacker, der indsætter skadelig kode i processen, f.eks. via en bufferoverløb, og udfører derefter denne kode.

Hvis du forsøger at angive instruktionsmarkøren til en hukommelsesadresse, der ikke er markeret som eksekverbar, medfører processoren en undtagelse (overtrædelse af generel beskyttelse), der medfører, at programmet går ned.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Alle eksekverbare ARM x64 og ARM-64 er som standard aktiveret i DEP, og de kan ikke deaktiveres. Da et program aldrig vil være blevet udført uden DEP, antages kompatibilitet.

Alle x86-binære (32-bit) har DEP aktiveret som standard, men DEP kan deaktiveres pr. proces. Nogle gamle ældre programmer, typisk programmer, der er udviklet før Windows XP SP2, er muligvis ikke kompatible med DEP. Sådanne programmer genererer typisk kode dynamisk (f.eks. JIT-kompilering) eller link til ældre biblioteker (f.eks. ældre versioner af ATL), som genererer kode dynamisk.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Aktivér ATL Thunk-emulering** – Denne konfigurationsindstilling deaktiverer ATL Thunk-emulering. ATL, ActiveX skabelonbibliotek, er designet til at være så lille og hurtigt som muligt. For at reducere binær størrelse, ville den bruge en teknik *kaldet thunking*. Thunking er normalt tænkt til at skulle arbejde mellem 32-bit- og 16-bit-programmer, men der er ingen 16-bit komponenter til ATL her. I stedet for at optimere for binær størrelse gemmer ATL maskinkode i hukommelsen, der ikke er ordjusteret (hvilket opretter en mindre binær), og aktiverer derefter denne kode direkte. ATL-komponenter, der er kompileret med Visual Studio 7.1 eller tidligere (Visual Studio 2003), tildeler ikke denne hukommelse som eksekverbar – thunk-emulering løser dette kompatibilitetsproblem. Programmer, der har en binær udvidelsesmodel (f.eks. Internet Explorer 11), skal ofte have ATL Thunk-emulering aktiveret.

## <a name="disable-extension-points"></a>Deaktiver udvidelsespunkter

### <a name="description"></a>Beskrivelse

Denne afhjælpning deaktiverer forskellige udvidelsespunkter for et program, som kan bruges til at etablere vedholdende eller hæve rettigheder til skadeligt indhold.

Dette omfatter:

- **AppInit DLL** – Når en proces starter, indlæser systemet den angivne DLL i konteksten for den nyligt startede proces, før det kalder sin indgangspunkt-funktion. [Oplysninger om AppInit-URL-adresser kan findes her](/windows/win32/winmsg/about-window-classes#application-global-classes). Når denne afhjælpning er anvendt, indlæses AppInit-URL-adresser ikke. Fra og Windows 7 skal AppInit-URL-adresser signeres digitalt som [beskrevet her](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2). Desuden indlæses AppInit-url-adresser ikke, Windows 8 der startes med SecureBoot, [som beskrevet her](/windows/win32/dlls/secure-boot-and-appinit-dlls).
- **Ældre ime'er** – Med en IME (Input Method Editor) kan en bruger skrive tekst på et sprog, der har flere tegn end det, der kan repræsenteres på tastaturet. Tredjeparter kan oprette chatbeskeder. En ondsindet IME kan hente legitimationsoplysninger eller andre følsomme oplysninger fra denne inputregistrering. Nogle chatbeskeder, der kaldes ældre chatbeskeder, fungerer kun på Windows-skrivebordsapps og ikke IWP-apps. Denne afhjælpning vil også forhindre, at denne ældre IME indlæses i den angivne Windows-skrivebordsappen.
- **Windows Event Hooks** – Et program kan kalde [SetWinEventHook API](/windows/win32/api/winuser/nf-winuser-setwineventhook) for at registrere interesse i en begivenhed, der finder sted. En DLL-fil angives og kan blive tilføjet i processen. Denne afhjælpning tvinger krogen til at blive sendt til registreringsprocessen i stedet for at køre proces gennem en tilføjet DLL-fil.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

De fleste af disse udvidelsespunkter bruges relativt sjældent, så kompatibilitetspåvirkningen er typisk lille, især på et enkelt programniveau. Den eneste overvejelse er, hvis brugerne bruger ældre chatbeskeder fra tredjepart, der ikke fungerer med det beskyttede program.

### <a name="configuration-options"></a>Konfigurationsindstillinger

Der er ingen konfigurationsindstillinger for denne afhjælpning.

> [!Note]
> **Deaktiver udvidelsespunkter** har ingen overvågningstilstand.

## <a name="disable-win32k-system-calls"></a>Deaktiver Win32k-systemopkald

### <a name="description"></a>Beskrivelse

Win32k.sys en bred angrebsoverflade for en hacker. Som en kernetilstandskomponent målrettes den ofte som en escape-vektor for programmer, der er sandkasse. Denne afhjælpning forhindrer opkald i win32k.sys at blokere en tråd i at konvertere sig selv til en GUI-tråd, som derefter får adgang til at aktivere Win32k-funktioner. En tråd er ikke-GUI, når den oprettes, men konverteres ved første opkald til win32k.sys eller via et API-opkald til [IsGuiThread](/windows/win32/api/winuser/nf-winuser-isguithread).

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Denne afhjælpning er beregnet til processer, der er dedikerede processer uden brugergrænseflade. Mange moderne browsere vil f.eks. bruge procesisolation og inkorporere ikke-UI-processer. Et program, der viser en GUI ved hjælp af en enkelt proces, vil blive påvirket af denne afhjælpning.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Microsoft Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="do-not-allow-child-processes"></a>Tillad ikke underordnede processer

### <a name="description"></a>Beskrivelse

Denne afhjælpning forhindrer, at et program opretter nye børneprogrammer. En almindelig metode, der bruges af adversarer, er at starte en pålidelig proces på enheden med skadeligt input (et angreb, der ofte kræver, at man starter et andet program på enheden). Hvis der ikke er nogen legitime årsager til, at et program kan starte en proces for børn, kan denne afhjælpning afhjælpe denne potentielle angrebsvektor. Afhjælpningen anvendes ved at angive en egenskab på procestoken, som blokerer oprettelse af et token for barnets proces med fejlmeddelelsen STATUS_CHILD_PROCESS_BLOCKED.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Hvis dit program starter underordnede programmer af en eller anden grund, f.eks. understøttende links, der starter en browser eller en ekstern browser, eller som starter andre funktioner på computeren, brydes denne funktionalitet med denne afhjælpning anvendt.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Microsoft Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="export-address-filtering"></a>Eksportér adressefiltrering

### <a name="description"></a>Beskrivelse

Filtrering af eksportadresser (EAF) mindsker risikoen for skadelig kode ved at se på eksportadressetabellen for alle indlæste moduler for at finde moduler, der indeholder nyttige API'er til deres angreb. Dette er en almindelig kodning, der bruges af shellcode. For at reducere risikoen for sådanne angreb beskytter denne afhjælpning tre ofte angrebsmoduler:

- ntdll.dll
- kernelbase.dll
- kernel32.dll

Afhjælpningen beskytter hukommelsessiden i [eksportmappen, der peger på [eksportadressetabellen](/windows/win32/debug/pe-format#export-address-table). Hukommelsessiden får [den PAGE_GUARD](/windows/win32/memory/creating-guard-pages) anvendt. Når nogen forsøger at få adgang til denne hukommelse, genererer den en STATUS_GUARD_PAGE_VIOLATION. Afhjælpningen håndterer denne undtagelse, og hvis adgangsvejledningen ikke består validering, afsluttes processen.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Denne afhjælpning er primært et problem for programmer som f.eks. fejlfinding, sandkasseprogrammer, programmer, der bruger DRM, eller programmer, der implementerer fejlfindingsteknologi.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Valider adgang for moduler** , der misbruges af udnyttelse – Denne indstilling, også kaldet EAF+, tilføjer beskyttelse til andre ofte angrebne moduler:

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

Ved at aktivere EAF+føjer denne afhjælpning desuden PAGE_GUARD-beskyttelsen til den side, der indeholder "MZ"-sidehovedet, de to første bytes i [DOS-sidehovedet](/windows/win32/debug/pe-format#ms-dos-stub-image-only) i en PE-fil, som er et andet aspekt af kendt hukommelsesindhold, som shellkode kan søge efter for at identificere moduler, som potentielt kan have interesse i hukommelsen.

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Microsoft Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="force-randomization-for-images-mandatory-aslr"></a>Gennemtving randomisering af billeder (mandatory ASLR)

### <a name="description"></a>Beskrivelse

ASLR (Address Space Layout Randomization) mindsker risikoen for, at en hacker bruger sin viden om systemets hukommelseslayout til at udføre kode, der allerede findes i proceshukommelsen og allerede er markeret som eksekverbar. Dette kan reducere risikoen for en hacker ved hjælp af teknikker som f.eks. return-to-libc-angreb, hvor adversæren angiver konteksten og derefter ændrer returadressen for at udføre en eksisterende kode med kontekst, der passer til modversens formål.

Obligatorisk ASLR gennemtvinger en genbase af alle URL-adresser i processen. En udvikler kan aktivere ASLR ved hjælp af [indstillingen /DYNAMICBASE-linker](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization) , og denne afhjælpning har samme effekt.

Når hukommelsesstyring tilknytter billedet i processen, vil obligatorisk ASLR automatisk genbaserebase for DLLs og EXEs, der ikke har tilmeldt sig ASLR. Bemærk dog, at denne rebasing ikke har entropy og derfor kan placeres på et forudsigeligt sted i hukommelsen. Denne afhjælpning bør danne par med [RANDOMize-hukommelsesallokeringer (Bottom-Up ASLR)](#randomize-memory-allocations-bottom-up-aslr) for at sikre en tilfældig placering af binære filer.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Denne kompatibilitetspåvirkning af ASLR er typisk begrænset til ældre programmer, der blev bygget ved hjælp af compilere, der gjorde forudsætninger om basisadressen for en binær fil eller har fjernet basisoplysninger. Dette kan føre til uforudsete fejl, da eksekveringsflowet forsøger at springe til det forventede, i stedet for den faktiske placering i hukommelsen.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Tillad ikke fjernede billeder – Denne** indstilling blokerer indlæsning af billeder, der har fået fjernet oplysninger fra skærmen. Windows PE-filformatet indeholder absolutte adresser, og compileren genererer også en [basisbelastende tabel, som loaderen kan bruge til at finde alle relative hukommelsesreferencer og deres forskydning, så de kan opdateres, hvis den binære ikke indlæses på dens foretrukne basisadresse. Nogle ældre programmer fjerne disse oplysninger i produktions builds, og derfor kan disse binære ikke genbases. Denne afhjælpning forhindrer, at disse binære indlæses (i stedet for at give dem mulighed for at indlæse på deres foretrukne basisadresse).

> [!Note]
> **Gennemtving randomisering af billeder (obligatorisk ASLR)** har ingen overvågningstilstand.

## <a name="import-address-filtering-iaf"></a>Importér adressefiltrering (IAF)

### <a name="description"></a>Beskrivelse

Afhjælpning af importadressefiltrering (IAF) hjælper med at reducere risikoen for en modgangsmand, der ændrer et programs kontrolstrøm ved at ændre tabellen med importadresser for at omdirigere til tilfældig kode for hackerens valg, når denne funktion kaldes. En hacker kunne bruge denne tilgang til at kapre kontrol eller opfange, undersøge og potentielt blokere opkald til følsomme API'er.

Hukommelsessiderne for alle beskyttede API'er får [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) anvendt. Når nogen forsøger at få adgang til denne hukommelse, genererer den en STATUS_GUARD_PAGE_VIOLATION. Afhjælpningen håndterer denne undtagelse, og hvis adgangsvejledningen ikke består validering, afsluttes processen.

Denne afhjælpning beskytter følgende Windows API'er:

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Legitime programmer, der udfører API-skæring, kan blive registreret af denne afhjælpning og medføre, at nogle programmer går ned. Eksempler er kompatibilitetsproblemer med sikkerhedssoftware og programmer.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Microsoft Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>Randomisere hukommelsesallokering (Bund-op ASLR)

### <a name="description"></a>Beskrivelse

Randomiser hukommelsesallokering (Bottom-up ASLR) føjer entropy til mennesker, så deres placering bliver tilfældigt og derfor mindre forudsigelig. Denne afhjælpning kræver obligatorisk aslr, før den træder i kraft.

Størrelsen på 32-bit adressepladsen lægger praktiske begrænsninger på den entropi, der kan tilføjes, og derfor gør 64-bit programmer det sværere for en hacker at gætte en placering i hukommelsen.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

De fleste programmer, der er kompatible med obligatorisk ASLR (rebasing), er også kompatible med den anden entropy af Bottom-up ASLR. Nogle programmer kan have problemer med afkortning af markør, hvis de gemmer lokale markører i 32-bit variabler (forventer en basisadresse på under 4 GB), og derfor er inkompatibel med indstillingen høj entropy (som kan deaktiveres).

### <a name="configuration-options"></a>Konfigurationsindstillinger

Brug ikke høj **entropy** – Denne indstilling deaktiverer brugen af høj entropy ASLR, hvilket tilføjer 24 bit af entropy (1 TB varians) i allokeringen nedefra og op for 64-bit programmer.

> [!Note]
> **Randomize memory allocations (Bottom-up ASLR)** har ingen overvågningstilstand.

## <a name="simulate-execution-simexec"></a>Simulere udførelse (SimExec)

### <a name="description"></a>Beskrivelse

Simuleret eksekvering (SimExec) er en afhjælpning af kun 32-bit-programmer. Dette hjælper med at validere, at opkald til følsomme API'er vender tilbage til legitime opkaldsfunktioner. Det gør den ved at opfange opkald i følsomme API'er og derefter udføre disse API'er ved at gå gennem den kodede samlingssproginstruktioner for at finde RET-vejledningen, som skal vende tilbage til den person, der ringer op. Den undersøger derefter denne funktion og går tilbage i hukommelsen for at finde den foregående KALD-instruktion for at afgøre, om funktionen og KALD-instruktionen stemmer overens, og at ret-funktionen ikke er blevet opfanget.

De API'er, der opfanges af denne afhjælpning, er:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Hvis der registreres en ROP-gadget, afsluttes processen.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Programmer, der udfører API-skæring, især sikkerhedssoftware, kan medføre kompatibilitetsproblemer med denne afhjælpning.

Denne afhjælpning er ikke kompatibel med vilkårlig Code Guard-afhjælpning.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Microsoft Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-api-invocation-callercheck"></a>Valider API-aktivering (CallerCheck)

### <a name="description"></a>Beskrivelse

Valider API-aktivering (CallerCheck) er en afhjælpning af returner-orienteret programmering (ROP)-teknikker, der validerer, at følsomme API'er kaldes fra en gyldig person, der ringer op. Denne afhjælpning undersøger den overførte returadresse og opdeler derefter bagud for at finde et opkald over returadressen for at afgøre, om opkaldsmålet stemmer overens med den parameter, der overføres til funktionen.

De API'er, der opfanges af denne afhjælpning, er:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Hvis der registreres en ROP-gadget, afsluttes processen.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Programmer, der udfører API-skæring, især sikkerhedssoftware, kan medføre kompatibilitetsproblemer med denne afhjælpning.

Denne afhjælpning er ikke kompatibel med vilkårlig Code Guard-afhjælpning.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Microsoft Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-exception-chains-sehop"></a>Valider undtagelseskæder (SEHOP)

### <a name="description"></a>Beskrivelse

Valider undtagelseskæder (SEHOP) er en afhjælpning mod *Structured Exception Handler (SEH) overskriver udnyttelsesteknik* . [Håndtering af strukturerede](/windows/win32/debug/structured-exception-handling) undtagelser er den proces, hvor et program kan bede om at håndtere en bestemt undtagelse. Undtagelsesbehandlere sammenkædes, så hvis én undtagelsesbehandler vælger ikke at håndtere en bestemt undtagelse, kan den overføres til den næste undtagelseshandler i kæden, indtil den ene vælger at håndtere den. Da listen over handleren er dynamisk, gemmes den i stakken. En hacker kan bruge en stak overløbssikkerhedsrisiko til derefter at overskrive undtagelsesbehandleren med en pointer til koden for hackerens valg.

Denne afhjælpning afhænger af designet af SEH, hvor hver SEH-post indeholder både en pointer til undtagelsesbehandleren samt en pointer til den næste handler i undtagelseskæden. Denne afhjælpning kaldes af undtagelsessenderen, der validerer SEH-kæden, når en undtagelse aktiveres. Det bekræfter, at:

- Alle undtagelseskædeposter er inden for stakgrænserne
- Alle undtagelsesposter justeres
- Ingen markør for undtagelseshandler peger på stakken
- Der er ingen bagudpegepinde
- Undtagelseskæden slutter ved en kendt sidste undtagelsesbehandler

Hvis disse valideringer mislykkes, afbrydes håndteringen af undtagelser, og undtagelsen håndteres ikke.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Kompatibilitetsproblemer med SEHOP er relativt sjældne. Det er ualmindeligt, at et program tager en afhængighed af at beskadige undtagelseskæden. Nogle programmer er dog påvirket af diskrete ændringer i tidsindstillingen, der kan opstå som en racertilstand, der viser en latente fejl med flere tråde i programmet.

### <a name="configuration-options"></a>Konfigurationsindstillinger

> [!Note]
> **Valider undtagelseskæder (SEHOP)** har ingen overvågningstilstand.

## <a name="validate-handle-usage"></a>Valider håndteringsforbrug

### <a name="description"></a>Beskrivelse

*Valider brugen af* håndtag er en afhjælpning, der beskytter mod hackere, der bruger et eksisterende håndtag til at få adgang til et beskyttet objekt. Et [håndtag](/windows/win32/sysinfo/handles-and-objects) er en reference til et beskyttet objekt. Hvis programkoden refererer til en ugyldig håndtag, kan det tyde på, at en adversær forsøger at bruge et håndtag, som den tidligere har registreret (men hvilken programreferenceoptælling, der ikke ville være opmærksom på). Hvis programmet forsøger at bruge et ugyldigt objekt i stedet for blot at returnere null, benytter programmet en undtagelse (STATUS_INVALID_HANDLE).

Denne afhjælpning anvendes automatisk på Windows Store programmer.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Programmer, der ikke nøjagtigt registrerer håndtagsreferencer, og som ikke ombrudte disse handlinger i undtagelseshandlerne, kan blive påvirket af denne afhjælpning.

### <a name="configuration-options"></a>Konfigurationsindstillinger

> [!Note]
> **Valider brugen af** håndtag har ingen overvågningstilstand.

## <a name="validate-heap-integrity"></a>Valider heap integritet

### <a name="description"></a>Beskrivelse

*Valideringen af afhjælpning af heapintegritet* øger beskyttelsesniveauet for omfattende afhjælpninger i Windows ved at forårsage, at programmet afsluttes, hvis der registreres en omfattende beskadigelse. Afhjælpningerne omfatter:

- Undgå, at et HEAP-håndtag bliver fri
- Udføre en anden validering på udvidede blokoverskrifter for heap-allokering
- Bekræftelse af, at allokeringer for heap ikke allerede er markeret som i brug
- Tilføjelse af Guard-sider til store allokeringer, heap-segmenter og undersegmenter over en minimumsstørrelse

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Denne afhjælpning anvendes allerede som standard for 64-bit-programmer og for 32-bit-programmer, Windows Vista eller nyere. Ældre programmer fra Windows XP eller tidligere er i de fleste tilfælde i fare, selvom kompatibilitetsproblemer er sjældne.

### <a name="configuration-options"></a>Konfigurationsindstillinger

> [!Note]
> **Validering af heapintegritet** har ingen overvågningstilstand.

## <a name="validate-image-dependency-integrity"></a>Valider billedes afhængighedsintegritet

### <a name="description"></a>Beskrivelse

*Valideringen af afhjælpning af billedafhængighed* er med til at beskytte dig mod angreb, der forsøger at erstatte kode for dll'er, som er statisk sammenkædet Windows binære. Teknik til DLL-anlægning misbruger loaders søgemekanismen til at indsætte skadelig kode, som kan bruges til at få skadelig kode til at køre i en høj kontekst. Når loaderen indlæser en Windows-signeret binær fil og derefter indlæser eventuelle dll-filer, som den binære afhænger af, bliver disse binære bekræftet for at sikre, at de også er digitalt signeret som en binær Windows fil. Hvis de ikke kan kontrollere signaturen, indlæses dll-filen ikke, og der vises en undtagelse, som returnerer en status som STATUS_INVALID_IMAGE_HASH.

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Kompatibilitetsproblemer er ualmindelige. Programmer, der afhænger af at erstatte Windows binære med lokale private versioner, vil blive påvirket, og der er også en lille risiko for at afsløre diskrete tidsindstillinger i programmer med flere tråde.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Microsoft Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-stack-integrity-stackpivot"></a>Valider stakintegritet (StackPivot)

### <a name="description"></a>Beskrivelse

Afhjælpningen af valideringen af stakintegriteten *(StackPivot)* hjælper med at beskytte sig mod Stakpivot-angreb, et ROP-angreb, hvor en hacker opretter en falsk stak i masser af hukommelse og derefter tricks programmet til at vende tilbage til den falske stak, der styrer flowet i eksekvering.

Denne afhjælpning opfanger mange Windows API'er og undersøger værdien af stakmarkøren. Hvis stakmarkørens adresse ikke falder mellem bunden og toppen af stakken, registreres en hændelse, og hvis den ikke er i overvågningstilstand, afsluttes processen.

De API'er, der opfanges af denne afhjælpning, er:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>Overvejelser i forbindelse med kompatibilitet

Programmer, der bruger falske stakke, påvirkes, og der er også en lille risiko for at afsløre diskrete tidsindstillinger i programmer med flere tråde.
Programmer, der udfører API-skæring, især sikkerhedssoftware, kan medføre kompatibilitetsproblemer med denne afhjælpning.

Denne afhjælpning er ikke kompatibel med vilkårlig Code Guard-afhjælpning.

### <a name="configuration-options"></a>Konfigurationsindstillinger

**Kun overvågning** – Du kan aktivere denne afhjælpning i overvågningstilstand for at måle den potentielle kompatibilitetspåvirkning for et program. Overvågningshændelser kan derefter vises enten i begivenhedsvisningen eller ved hjælp af Avanceret jagt [i Microsoft Defender til slutpunkt](/microsoft-365/security/defender/advanced-hunting-overview).
